//var crypto = require('crypto');

var util = require("util");
var EventEmitter = require('events').EventEmitter;

function UcpFeature(featureModel) {
    this.readModel(featureModel);
    this.subscribers = [];
    this.mappings = {};
}

util.inherits(UcpFeature, EventEmitter);

/*
{
    type: 'bool',
    label: 'Switch',
    data: 0,
    set: function(value, cb) {
        razberryHost.write(deviceId, 0, 37, value, cb);
    }
}
*/
    
UcpFeature.prototype.readModel = function(model) {
    
    //this.type = model.type;
    
    for (var i in model) {
        if ( this[i] ) {
            console.log("Could not add feature successfully, due to existing property", i, model, new Error().stack);
            return;
        } else {
            this[i] = model[i];
        }
    }
};

UcpFeature.prototype.read = function(opts, cb) {
    cb(null, this.data);
};

UcpFeature.prototype.subscribe = function(opts, cb) {
    this.subscribers.push({ endpoint: opts.peer, cb: cb });
    cb(null, this.data);
};

/**
 * 
 * 
 * key Unique key for mapping
 * settings { endpoint: { url, epid }, opts: {} }
 * opts Wish context
 * cb
 * @returns key
 */
UcpFeature.prototype.map = function(key, settings, opts, cb) {   
    var mapping = {
        endpoint: {
            url: settings.url,
            epid: settings.epid
        },
        opts: settings.opts
    };
    this.mappings[key] = mapping;
    cb(null, key);
};

UcpFeature.prototype.unMap = function (key, opts, cb) {
    var self = this;
    if (this.mappings[key]) {
        this.emit('notification', [this.mappings[key].endpoint, key, 'del'], function (err, data) {
            if (!err) {
                //console.log('Mapping deleted');
            }
        });
        delete self.mappings[key];
        self.emit('uppdateMappings');
        cb(null);
    } else {
        cb(null, 'Wrong key');
    }
};

UcpFeature.prototype.notify = function(id, payload, opts, cb) {    
    if (this.mappings[id]) {
        if (payload === 'del') {
            delete this.mappings[id];
            this.emit('uppdateMappings');
            cb(null);
        } else {
            if (this.mappings[id].opts.type === 'write') {
                opts.epid = this.mappings[id].endpoint.epid;
                this.write(payload, opts, cb);
            }
        }
    }
};

UcpFeature.prototype.loadMappings = function(mappings) {
    //fs.readFile(__dirname + '/db/ma');
    this.mappings = mappings;
};

UcpFeature.prototype.deviceUpdate = function(value) {
    if ( this.data !== value && !(isNaN(this.data) && isNaN(value)) ) {
        // changed!!
        this.data = value;
        for (var i = this.subscribers.length-1; i>=0; i--) {
            var success = this.subscribers[i].cb(null, value);
            if ( success === false ) {
                console.log("This subscriber canceled.");
                this.subscribers.splice(i,1);
            }
        }
        
        for (var i in this.mappings) {
            var opts = this.mappings[i].opts;
            
            if (opts.type === 'direct' ) {
                if ( opts.interval === 'change' ) {
                    this.emit('notification', [this.mappings[i].endpoint, i, value]);
                }
            }
            
        }
    }
};

module.exports = {
    UcpFeature: UcpFeature};
