var UcpDevice = require('./ucp-device.js').UcpDevice;
var debug = require('debug')('mist-helper-app');

// WishApp/WishService service, MistModel model, MistDevice 
function Application(service, model, device) { 
    this.ucpDevice = new UcpDevice(model.model.mist.name, model.model);    
    if(service) {
        this.ucpDevice.attachInterface(service);
    } else {
        // can probably be removed in a later cleanup
        this.wishAppAttachTimeout = setTimeout(function() { console.log("Attach the WishApp to the ucp device manually, as no App was given in constructor."); }, 200);
    }
    this.model = this.ucpDevice.features;
    this.device = device;
    this.parse();
}

Application.prototype.attachInterface = function(service) {
    this.ucpDevice.attachInterface(service);
    // can probably be removed in a later cleanup
    clearTimeout(this.wishAppAttachTimeout);
};

Application.prototype.updateFeature = function (id, value) {
    this.ucpDevice.getFeature(id).deviceUpdate(value);
};

Application.prototype.addFeature = function (id, obj) {
   this.model(id, obj);
   this.addToDevice(id, this.model[id]);
};

// Find the method in mist device to which we can map incoming calls, i.e. 
//  control.write('battery.maintenance.dischargeInterval', 362) will map to
//  MistDevice.battery.maintenance.dischargeInterval = function(value, opts, cb) {}
Application.prototype.getDeviceMethod = function (id) {
    try {
        var path = id.split('.');
        var epid = path.shift();
        var cur = this.device[epid];
        while(path.length>0) {
            epid = path.shift();
            cur = cur[epid];
        }
        return typeof cur === 'function' ? cur.bind(this.device) : null;
    } catch(e) {
        //console.log("Failed getting endpoint from device:", epid, this.device, e);
        return null;
    }
};

Application.prototype.addToDevice = function (id, feature) {
    if (this.device) {
        var endpoint = this.getFeature(id);
        var deviceMethod = this.getDeviceMethod(id);
        
        // if(!deviceMethod) { console.log("Was expecting device to contain method:", id, 'but it was not found. Check your mist device.'); }
        
        if (endpoint && deviceMethod) {
            if (feature['write']) {
                endpoint.write = function (value, opts, cb) {
                    deviceMethod(value, opts, cb);
                };
            }
            if (feature['invoke']) {
                endpoint.invoke = function (args, opts, cb) {
                    deviceMethod(args, opts, cb);
                };
            }
        }
    }
};

Application.prototype.getFeature = function (id) {
    try {
        var path = id.split('.');
        var epid = path.shift();
        var cur = this.model[epid];
        while(path.length>0) {
            epid = path.shift();
            cur = cur.features[epid];
        }
        return cur;
    } catch(e) {
        console.log("Failed getting endpoint from model:", path, e);
        return null;
    }
};

Application.prototype.addToApplication = function (id, feature) {
    var self = this;
    if (this.getFeature(id) !== null) {
        if (typeof feature.data !== 'undefined' ||Â typeof feature.read === 'function') {
            //console.log("Adding listener for:", id);
            this.device.on(id, function (value) {
                self.updateFeature(id, value);
            });
        }
    } else {
        console.log('addToApplication: could not find feature', id);
    }
};

Application.prototype.parse = function () {
    var self = this;
    function doit(feature, path) {
        for (var i in feature) {
            var fullname = (path ? path +'.' : '') + i;

            //console.log("Adding ", fullname, feature[i]);
            self.addToApplication(fullname, feature[i]);
            self.addToDevice(fullname, feature[i]);
            
            if(typeof feature[i].features === 'object') {
                //console.log("Found subitems for:", i, 'these:', feature[i].features);
                doit(feature[i].features, fullname);
            }
        }
    }
    doit(this.model);
};

module.exports = {
    Application: Application
};
