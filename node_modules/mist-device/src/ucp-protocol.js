var Protocol = require('wish-app').Protocol;
var Peer = require('wish-app').Peer;
var debug = require('debug')('mist-device');
var crypto = require('crypto');


function UcpProtocol() {
    var self = this;
    this.followPeers = {};

    this.ucp = new Protocol('ucp', {
        _control: {},
        control: {
            _read: { public: true },
            read: function(req, res, context) {
                var ep = req.args[0];
                this.acl('model.'+ep, 'read', function(err, allowed) {
                    if(err) { res.error({ str: 'Access control failed.' }); }
                    if(allowed) {
                        self.read(ep, { peer: context.peer }, function(err, data) {
                            if (err) { return res.error(data); }
                            res.send(data);
                        });
                    } else {
                        res.error({ str: 'Permission denied.' });
                    }
                });
            },
            _write: { public: true },
            write: function(req, res, context) {
                var ep = req.args[0];
                this.acl('model.'+ep, 'write', function(err, allowed) {
                    if(err) { res.error({ str: 'Access control failed.' }); }
                    if(allowed) {
                        self.write(ep, req.args[1], { peer: context.peer }, function(err, data) {
                            if (err) { return res.error(data); }
                            res.send({});
                        });
                    } else {
                        res.error({ str: 'Permission denied.' });
                    }
                });
            },
            _invoke: { public: true },
            invoke: function(req, res, context) {
                var ep = req.args[0];
                this.acl('model.'+ep, 'invoke', function(err, allowed) {
                    if(err) { res.error({ str: 'Access control failed.' }); }
                    if(allowed) {
                        self.invoke(req.args[0], req.args[1], { peer: context.peer }, function(err, data) {
                            if (err) { return res.error(data); }
                            res.send(data);
                        });
                    } else {
                        res.error({ str: 'Permission denied.' });
                    }
                });
            },
            _follow: { public: true },
            follow: function(req, res, context) {
                var q = this;
                
                self.follow(req.args, { peer: context.peer }, function(err, data) {
                    if (err) { return res.error(data); }
                    try {
                        res.emit(data);
                    } catch(e) {
                        console.log("Closed this follow request.", q);
                        res.close();
                        return false;
                    }
                });
                
                this.end = function() {
                    //console.log("follow request has ended.");
                    var peer = context.peer;
                    self.followPeers[peer.luid+'>'+peer.ruid+'@'+peer.rhid+'/'+peer.rsid] = false;
                    // this should probably be moved to UcpDevice and just called from here (and offline signal handler)
                    self.ucpDevice.foreachEndpoint(function(path, key, endpoint) {
                        if(!endpoint.subscribers) { return; }

                        for(var j in endpoint.subscribers) {
                            var ep = endpoint.subscribers[j].endpoint;
                            if (peer.luid === ep.luid && peer.ruid === ep.ruid && peer.rhid === ep.rhid && peer.rsid === ep.rsid) {
                                //debug("Remove subscription:", path, '=>', peer.r+ '@' +peer.rhid+ '/' +peer.rsid);
                                endpoint.subscribers.splice(j, 1);
                            }
                        }
                    });                   
                };
            },
            _map: {
                args: '',
                public: true
            },
            map: function(req, res, context) { 
                var srcEpid = req.args[0]; // axis1
                var srcOpts = req.args[1];
                var dstEpid = req.args[2];

                var dstUrl = 'wish://'+context.peer.luid+'>'+context.peer.ruid+'@'+context.peer.rhid+'/'+context.peer.rsid;
                var key = crypto.createHash('sha1').update(JSON.stringify(req)).digest('hex').substr(0, 8);

                var settings = { 
                    epid: dstEpid, 
                    url: dstUrl, 
                    opts: srcOpts };

                self.map(key, srcEpid, settings, { peer: context.peer }, function(err, data) {
                    if (err) { return res.error(data); }
                    res.send(data);
                });
            },
             _unMap: { public: true },
            unMap: function(req, res, context) {
                self.unMap(req.args[0], req.args[1], { peer: context.peer }, function(err, data) {
                    if (err) { return res.error(data); }
                    res.send(data);
                });
            },
            _notify: { public: true },
            notify: function(req, res, context) {
                // add ACL checks here
                self.notify(req.args[0], req.args[1], req.args[2], { peer: context.peer }, function(err, data) {
                    if (err) { return res.error(data); }
                    res.send(data);
                });
            },
            _requestMapping: {
                args: '',
                public: true
            },
            requestMapping: function(req, res, context) {
                // add ACL checks here
                var key = crypto.createHash('sha1').update(JSON.stringify(req)).digest('hex').substr(0, 8);

                var from = req.args[0];     // j
                var fromEpid = req.args[1]; // axis1
                var fromOpts = req.args[2]; // { type: 'direct', interval: 'change' }
                var toEpid = req.args[3];   // vibrateStrong
                var toOpts = req.args[4];   // { type: 'write' }

                /*
                d.control.requestMapping(j, 'axis1', { type: 'direct', interval: 'change' }, 'vibrateStrong', { type: 'write' });

                */

                from.luid = context.peer.luid;
                if (from.rhid === 'localhost'){
                    from.rhid = context.peer.rhid;
                }            
                var url = 'wish://'+from.luid+'>'+from.ruid+'@'+from.rhid+'/'+from.rsid; 
                var peer = { luid: from.luid, ruid: from.ruid, rhid: from.rhid, rsid: from.rsid };

                //j.control.map('axis1', { type: 'direct', interval: 'change' }, 'vibrateStrong', function(err, key) {})
                self.ucp.request(peer, 'control.map', [fromEpid, fromOpts, toEpid], function(err, key) {
                    if (err) { return res.error(key); }
                    //console.log("control map response(err,data):", err, key);

                    var settings = {
                        epid: fromEpid,
                        url: url,
                        opts: toOpts };

                    // key, toEpid, toOpts
                    self.map(key, toEpid, settings, { peer: context.peer }, function (err, data) {
                        res.send(data);
                    });
                });
            },        
            _model: { public: true },
            model: function(req, res, context) {
                var acl = this.acl;
                self.model({ peer: context.peer }, function(err, data) {
                    //if (err) { return res.error(data); }
                    //res.send(data);
                    
                    var model = {
                        device: data.device, // The predefined vendor given name
                        // name: 'My device' // renameable device name
                        model: {},
                        enum: data.enum
                    };

                    var c = 0;
                    for(var i in data.model) {
                        c++;
                        (function parseEndpoint(idx, path, ep, modelCursor) {
                            acl('model.'+path, ['view', 'read', 'write', 'invoke'], function(err, allowed, what) {
                                //console.log("ACL check: getFeatureModel:", i, 'view', allowed, what, ep);
                                if(idx === 'mist' || idx === 'version') {
                                    modelCursor[idx] = ep;
                                } else if(ep.features) {
                                    if(what.indexOf('view') !== -1) {
                                        var features = {};
                                        modelCursor[idx] = { label: ep.label, type: 'object', features: features };
                                        //console.log("Here we got some sub-features...");
                                        for(var j in ep.features) {
                                            c++;
                                            parseEndpoint(j, path+'.'+j, ep.features[j], features);
                                        }
                                    }
                                } else if(allowed) {
                                    var copy = { label: ep.label, type: ep.type }; // , data: ep.data
                                    if(ep.unit) { copy.unit = ep.unit; };
                                    if(ep.scale) { copy.scale = ep.scale; };
                                    if(ep.mappings) { copy.mappings = ep.mappings; };
                                    if(ep.ref) { copy.ref = ep.ref; }; // ref contains enum identifier if present
                                    if(ep.hint) { copy.hint = ep.hint; };
                                    if(ep.read && what.indexOf('read') !== -1) { copy.read = true; }
                                    if(ep.write && what.indexOf('write') !== -1) { copy.write = true; }
                                    if(ep.invoke && what.indexOf('invoke') !== -1) { copy.invoke = true; }
                                    
                                    modelCursor[idx] = copy;
                                }
                                c--;
                                if(c===0) {
                                    res.send(model);
                                }
                            });
                        })(i, i, data.model[i], model.model);
                    }
                });
            }
        },
        _manage: {},
        manage: {
            _claim: { public: true },
            claim: function(req, res, context) {
                // add ACL and lockdown checks here
                self.root = context.peer;

                var luid = context.peer.luid; // who is allowing access
                var role = 'owner';
                var user = Peer.toRemoteUrl(context.peer); // who is the user
                
                self.ucp.app.core('services.acl.addUserRoles', [luid, user, role], function(err, data) {
                    res.send({msg:'You are now in owner group.', peer: context.peer});
                });                    
            },
            _peers: { public: true },
            peers: function(req, res, context) {
                // add ACL checks here
                var l = [];
                for(var i in self.ucp.peerCache) {
                    l.push(Peer.copyCleanOnline(self.ucp.peerCache[i]));
                }
                res.send(l);
            },
            _acl: {},
            acl: {
                _model: { public: true },
                model: function(req, res, context) {
                    // add ACL checks here
                    var acl = this.acl;
                    var roles = ['admin', 'user', 'guest'];

                    function whatResources() {
                        var a = {};
                        var c = 0;
                        var t = 0;

                        for(var i in roles) {
                            c++;
                            t++;
                            (function(a, i) {
                                var role = roles[i];
                                self.ucp.app.core('services.acl.whatResources', [context.peer.luid, role], function(err, data) {
                                    //console.log("whatResources:", role, data);
                                    a[role] = data;
                                    c--;
                                    if(c===0) {
                                        //console.log("we're done! checked items:", t, a);
                                        createAclModel(a);
                                    }
                                });
                            })(a, i);
                        }
                    }
                    
                    whatResources();

                    function createAclModel(access) {
                        self.model({ peer: context.peer }, function(err, data) {
                            if (err) { return res.error(data); }

                            var aclModel = {};

                            function parse(a, o) {
                                for(var i in o) {
                                    if(i === 'mist') { continue; }
                                    if(i === 'version') { continue; }
                                    a[i] = { label: o[i].label };
                                    if(o[i].read || o[i].data) { a[i].read = true; }
                                    if(o[i].write) { a[i].write = true; }
                                    if(o[i].invoke) { a[i].invoke = true; }

                                    for(var r in roles) {
                                        var role = roles[r];

                                        if(access[role]['ucp#model.'+i]) {
                                            if(!a[i]._roles) { a[i]._roles = {}; }
                                            a[i]._roles[role] = access[role]['ucp#model.'+i];
                                        }
                                    
                                    }

                                    // check for children
                                    if(o[i].features) {
                                        //a[i].features = {};
                                        parse(a[i], o[i].features);
                                    }
                                }
                                //console.log("a", a);
                            }

                            parse(aclModel, data.model);
                            res.send(aclModel);
                        });
                        
                    }
                },
                _allow: { public: true, args: 'Role, Endpoint (battery.status), Permission read/write' },
                allow: function(req, res, context) {
                    // add ACL checks here
                    var luid = context.peer.luid; // who is allowing access
                    var role = req.args[0]; // who is the remote user
                    var endpoint = req.args[1]; // which resource
                    var permission = req.args[2]; // what permission(s)
                    
                    var prefix = self.ucp.name +'#model.';
                    var resource = prefix + endpoint;
                    //console.log("I'm going to allow this:", luid, role,  resource, permission);
                    //console.log("Should be prefixed with protocol name and stuff:", self.ucp);
                    self.ucp.app.core('services.acl.allow', [luid, role, resource, permission], function(err, data) {
                        //console.log("UcpProtocol.manage.acl.allow: Core allow:", err, data);
                        res.send(!err);
                    });                    
                },
                _removeAllow: { public: true, args: 'Role, Endpoint (battery.status), Permission read/write' },
                removeAllow: function(req, res, context) {
                    // add ACL checks here
                    var luid = context.peer.luid; // who is allowing access
                    var role = req.args[0]; // who is the remote user
                    var endpoint = req.args[1]; // which resource
                    var permission = req.args[2]; // what permission(s)
                    
                    var prefix = self.ucp.name +'#model.';
                    var resource = prefix + endpoint;
                    //console.log("I'm going to removeAllow this:", luid, role,  resource, permission);
                    //console.log("Should be prefixed with protocol name and stuff:", self.ucp);
                    self.ucp.app.core('services.acl.removeAllow', [luid, role, resource, permission], function(err, data) {
                        //console.log("UcpProtocol.manage.users.removeAllow: Core removeAllow:", err, data);
                        res.send(!err);
                    });                    
                },
                _addUserRoles: { public: true, args: 'Role, Endpoint (battery.status), Permission read/write' },
                addUserRoles: function(req, res, context) {
                    // add ACL checks here
                    var luid = context.peer.luid; // who is allowing access
                    var user = Peer.toRemoteUrl(req.args[0]); // who is the user
                    var role = req.args[1]; // which role to add
                    self.ucp.app.core('services.acl.addUserRoles', [luid, user, role], function(err, data) {
                        //console.log("UcpProtocol.manage.acl.addUserRoles: Core addUserRoles:", err, data);
                        res.send(data);
                    });                    
                },
                _removeUserRoles: { public: true, args: 'Role, Endpoint (battery.status), Permission read/write' },
                removeUserRoles: function(req, res, context) {
                    // add ACL checks here
                    var luid = context.peer.luid; // who is allowing access
                    var user = Peer.toRemoteUrl(req.args[0]); // who is the user
                    var role = req.args[1]; // which role to add
                    self.ucp.app.core('services.acl.removeUserRoles', [luid, user, role], function(err, data) {
                        //console.log("UcpProtocol.manage.acl.removeUserRoles: Core removeUserRoles:", err, data);
                        res.send(data);
                    });                    
                },
                _userRoles: { public: true, args: '[Peer]', docs: 'If peer is not given, requesting peer is used.' },
                userRoles: function(req, res, context) {
                    // add ACL checks here
                    var luid = context.peer.luid; // who is allowing access
                    var user;
                    if(!req.args[0]) {
                        user = Peer.toRemoteUrl(context.peer);
                    } else {
                        user = Peer.toRemoteUrl(req.args[0]); // who is the user
                    }
                    self.ucp.app.core('services.acl.userRoles', [luid, user], function(err, data) {
                        //console.log("UcpProtocol.manage.acl.userRoles: Core userRoles:", err, data);
                        res.send(data);
                    });                    
                }                
            },
            _users: {},
            users: {
                _add: { acl: true },
                add: function(req, res, context) {
                    self.ucp.app.core('identity.import', [req.args[0], context.peer.luid], function(err, data) {
                        res.send(data);
                    });
                },
                _allow: { public: true, args: 'Peer, Endpoint (battery.status), Permission read/write' },
                allow: function(req, res, context) {
                    var luid = context.peer.luid; // who is allowing access
                    var peer = Peer.toRemoteUrl(req.args[0]); // who is the remote user
                    var endpoint = req.args[1]; // which resource
                    var permission = req.args[2]; // what permission(s)
                    
                    var prefix = self.ucp.name +'#model.';
                    var resource = prefix + endpoint;
                    console.log("I'm going to allow this:", luid, peer,  resource, permission);
                    //console.log("Should be prefixed with protocol name and stuff:", self.ucp);
                    self.ucp.app.core('services.acl.allow', [luid, peer, resource, permission], function(err, data) {
                        console.log("UcpProtocol.manage.acl.allow: Core allow:", err, data);
                    });                    
                },
                _removeAllow: { public: true, args: 'Peer, Endpoint (battery.status), Permission read/write' },
                removeAllow: function(req, res, context) {
                    var luid = context.peer.luid; // who is allowing access
                    var peer = Peer.toRemoteUrl(req.args[0]); // who is the remote user
                    var endpoint = req.args[1]; // which resource
                    var permission = req.args[2]; // what permission(s)
                    
                    var prefix = self.ucp.name +'#model.';
                    var resource = prefix + endpoint;
                    console.log("I'm going to allow this:", luid, peer,  resource, permission);
                    //console.log("Should be prefixed with protocol name and stuff:", self.ucp);
                    self.ucp.app.core('services.acl.removeAllow', [luid, peer, resource, permission], function(err, data) {
                        console.log("UcpProtocol.manage.users.removeAllow: Core removeAllow:", err, data);
                    });                    
                }
            }
        }
    });
    
    this.ucp.on('offline', function(peer) {
        debug("A peer went offline.", peer.l+ '>' +peer.r+ '@' +peer.rhid+ '/' +peer.rsid);
        self.followPeers[peer.luid+'>'+peer.ruid+'@'+peer.rhid+'/'+peer.rsid] = false;
        // this should probably be moved to UcpDevice and just called from here (and follow.end)
        self.ucpDevice.foreachEndpoint(function(path, key, endpoint) {
            if(!endpoint.subscribers) { return; }
            
            for(var j in endpoint.subscribers) {
                var ep = endpoint.subscribers[j].endpoint;
                if (peer.luid === ep.luid && peer.ruid === ep.ruid && peer.rhid === ep.rhid && peer.rsid === ep.rsid) {
                    //debug("Remove subscription:", path, '=>', peer.r+ '@' +peer.rhid+ '/' +peer.rsid);
                    endpoint.subscribers.splice(j, 1);
                }
            }
        });
    });
    
    this.ucp.on('online', function(peer) {
        debug("A peer came online.", peer.l+ '>' +peer.r+ '@' +peer.rhid+ '/' +peer.rsid);
    });
    
    this.interface = {
        model: function(peer, cb) {
            self.ucp.request(peer, 'control.model', [], cb);
        },
        write: function(peer, feature, value, cb) {
            self.ucp.request(peer, 'control.write', [feature, value], cb);
        },
        invoke: function(peer, feature, args, cb) {
            self.ucp.request(peer, 'control.invoke', [feature, args], cb);
        },
        follow: function(peer, cb) {
            self.ucp.request(peer, 'control.follow', [], cb);
        },
        manage: {
            peers: function(peer, cb) {
                self.ucp.request(peer, 'manage.peers', [], cb);
            }
        }
    };
}

UcpProtocol.prototype.attachUcpDevice = function(device) {
    this.ucpDevice = device;
    this.emits();
};

UcpProtocol.prototype.write = function(feature, value, opts, cb) {
    this.ucpDevice.write(feature, value, opts, cb);
};

UcpProtocol.prototype.invoke = function(feature, args, opts, cb) {
    this.ucpDevice.invoke(feature, args, opts, cb);
};

UcpProtocol.prototype.read = function(feature, opts, cb) {
    this.ucpDevice.read(feature, opts, cb);
};

UcpProtocol.prototype.model = function(opts, cb) {
    this.ucpDevice.model(opts, cb);
};

UcpProtocol.prototype.follow = function(filter, opts, cb) {
    this.ucpDevice.follow(filter, opts, cb);
};

UcpProtocol.prototype.map = function (key, epid, settings, opts, cb) {
    var self = this;
    this.ucpDevice.map(key, epid, settings, opts, function (err, data) {
        cb(err, data);
        if (!err) {
            self.ucpDevice.serialize(function (err, data) {
                if (!err) {
                    self.ucpDevice.saveMappings(data);
                }
            });
        }
    });
};

UcpProtocol.prototype.unMap = function(key, epid, opts, cb) {
    this.ucpDevice.unMap(key, epid, opts, cb);
};

UcpProtocol.prototype.notify = function(epid, id, payload, opts, cb) {
    this.ucpDevice.notify(epid, id, payload, opts, cb);
};

UcpProtocol.prototype.emits = function() {
    var self = this;
    this.ucpDevice.on('notification', function (req) {
        var peer = Peer.fromUrl(req[0].url);
        self.ucp.request(peer, 'control.notify', [req[0].epid, req[1], req[2]]);
    });
};

module.exports = {
    UcpProtocol: UcpProtocol };
