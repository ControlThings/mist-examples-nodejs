var UcpFeature = require('./ucp-feature').UcpFeature;
var EventEmitter = require('events').EventEmitter;
var util = require("util");
var fs = require("fs");
var path = require('path');
var mkdirp = require('mkdirp');
var debug = require('debug')('UcpDevice');

function UcpDevice(name, model) {
    this.name = name;
    this.features = {};
    this.enum = {};
    this.dataDir = '.';
    if (model) {
        this.parseModel(model);
    }
    
    this.init();
}

util.inherits(UcpDevice, EventEmitter);

UcpDevice.prototype.parseModel = function(model) {
    var self = this;
    
    function doit(model, path) {
        for(var i in model) {
            var o = model[i];
            var fullname = (path ? path +'.' : '') + i;
            if (i==='mist') { self.addMeta(i, o); continue; }
            switch(o.type) {
                case 'enum':
                    self.enum[i] = o;
                    break;
                case 'slot':
                case 'signal':
                case 'string':
                case 'any': // used by loggers etc that can handle any data
                case 'array':
                case 'meta':
                case 'uint8':
                case 'uint16':
                case 'int8':
                case 'int16':
                case 'invoke':
                case 'float':
                case 'bool':
                case 'data':
                    //console.log("Adding feature "+fullname+" from:", o);
                    self.addFeature(fullname, new UcpFeature(o));
                    break;
                default:
                    //console.log("defaulting  "+fullname+" ..", o.type);
                    self.addFeature(fullname, new UcpFeature(o));
            }
            if (o.features) {
                doit(o.features, fullname);
            }
        }
    }
    doit(model);
    //console.log("doitmodel:", util.inspect(this.features, 10, null, true));
};

UcpDevice.prototype.foreachEndpoint = function(cb) {
    function parse(features, path) {
        for(var i in features) {
            var fullname = (path ? path +'.' : '') + i;
            cb(fullname, i, features[i]);
            if(features[i].features) {
                parse(features[i].features, fullname);
            }
        }
    }
    parse(this.features);
};
    
UcpDevice.prototype.getFeature = function(id) {
    try {
        var path = id.split('.');
        var epid = path.shift();
        var cur = this.features[epid];
        while(path.length>0) {
            epid = path.shift();
            cur = cur.features[epid];
        }
        return cur;
    } catch(e) {
        console.log("Failed getting endpoint from model:", epid, this.features, e);
        return null;
    }
};

UcpDevice.prototype.init = function() {
    var dir;
    
    if ( process.env.MIST_DATA ) {
        dir = process.env.MIST_DATA;
    } else if ( process.platform === 'win32' ) {
        // we should access files from local APPDATA if access to current directory is not writable (in case we are installed in Program Files directory)
        dir = process.env.LOCALAPPDATA+"/MistDevice"+this.name;
    } else { // expecting nix
        dir = path.resolve(process.env.HOME+"/.mist-device-"+this.name.toLowerCase());
    }
    
    try {
        mkdirp.sync(dir);
    } catch (e) {
        if( e.code === 'EACCES' ) {
            console.log("Could not create directory ", dir, ". Permission denied.");
        } else {
            console.log("Could not create directory ", dir, ".", e);
        }
        process.exit(2);
    }
    
    debug('Using data dir: ' + dir);
    
    this.dataDir = dir;
};

function hasMappings(obj) {
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) {
            return true;
        }
    }
}

UcpDevice.prototype.serialize = function(cb) {
    
    var l = {};
    for (var i in this.features) {
        var map = this.features[i].mappings;
        if (hasMappings(map)) {
            l[i] = { mappings: map };
        }
    }  
    cb(null, JSON.stringify(l));
};

UcpDevice.prototype.deserialize = function(data) {
    var state = JSON.parse(data);
    for (var i in state) {
        if (this.features[i]) {
            this.features[i].loadMappings(state[i].mappings);         
        }
    }
};

UcpDevice.prototype.saveMappings = function (data) {
    if (data.length <= 2) {
        fs.unlink(this.mapFile, function (err) {
            if (err) {
            }
        });
    } else {
        fs.writeFile(this.mapFile, data, function (err) {
            if (err) {
            }
        });
    }
};

UcpDevice.prototype.loadMappings = function(cb) {
    var self = this;
    fs.readFile(this.mapFile, function (err, data) {
        if (err) { return cb(err); }
        
        if (data) {
            self.deserialize(data);
            cb(null);
        }
    });
};

UcpDevice.prototype.attachInterface = function(interface) {
    var self = this;
    var wsid = '';
    
    if (interface.app) {
        if (!interface.app.wsid) {
            console.log("ucp-device.js attachInterface could not resolve WSID.");
            process.exit(4);
        } else {
            wsid = interface.app.wsid;
        }
    } else if (interface.ucp.app) {
        if (!interface.ucp.app.wsid) {
            console.log("ucp-device.js attachInterface could not resolve WSID from ucp.");
            process.exit(4);
        } else {
            wsid = interface.ucp.app.wsid;
        }
    } else {
        console.log("ucp-device.js attachInterface could not resolve WSID from interface given.", interface, new Error().stack);
    }

    this.mapFile = this.dataDir + '/mappings-' + wsid + '.json';
    this.loadMappings(function (err, data) {
        if (err) {
            debug("No mappings loaded. ", self.mapFile);
        }
    });
    
    interface.attachUcpDevice(this);
    this.interface = interface;
};

UcpDevice.prototype.addFeature = function(id, feature) {
    var self = this;

    var path = id.split('.');
    var epid = path.shift();
    if(!this.features[epid]) {
        this.features[epid] = {};
    }
    if(path.length === 0) { this.features[epid] = feature; }

    var cur = this.features[epid];

    while(path.length>0) {
        epid = path.shift();
        //console.log("===========0creating epid", epid);
        if(!cur.features) {
            cur.features = {};
        }
        if(path.length===0) {
            cur.features[epid] = feature;
        }
        cur = cur.features[epid];
    }
    //cur = feature;
    cur.on('notification', function(req){
        self.emit('notification', req);
    });
    cur.on('uppdateMappings', function () {
        self.serialize(function (err, data) {
            if (!err) {
                self.saveMappings(data);
            }
        });
    });
};

UcpDevice.prototype.addMeta = function(id, meta) {
    if(this.features[id]) {
        console.log("Overwrite meta", id, meta);
        this.features[id] = meta;
    } else {
        this.features[id] = meta;
    }
};

UcpDevice.prototype.addEnum = function(id, map) {
    if(this.enum[id]) {
        return null;
    } else {
        this.enum[id] = map;
    }
};

UcpDevice.prototype.write = function(id, value, opts, cb) {
    var endpoint = this.getFeature(id);
    if(!endpoint) {
        return cb(true, 'Not found: '+id);
    }
    if(typeof endpoint.write !== 'function') {
        return cb(true, 'Not writable: '+id);
    }
    
    endpoint.write(value, opts, cb);
};

UcpDevice.prototype.invoke = function(id, args, opts, cb) {
    var endpoint = this.getFeature(id);
    if(!endpoint) {
        return cb(true, 'Not found: '+id);
    }
    if(typeof endpoint.invoke !== 'function') {
        return cb(true, 'Not invokable: '+id);
    }
    
    endpoint.invoke(args, opts, cb);
};

UcpDevice.prototype.follow = function(filter, opts, cb) {
    this.foreachEndpoint(function(path, key, endpoint) {
        if(typeof endpoint.subscribe === 'function' && typeof endpoint.data !== 'undefined') {
            endpoint.subscribe(opts, function(err, data) {
                return cb(null, {id: path, data: data});
            });
        }
    });
};

// from and to endpoints (wish url + mist/ucp feature id)
UcpDevice.prototype.map = function(key, epid, settings, opts, cb) {
    this.features[epid].map(key, settings, opts, cb);
};

UcpDevice.prototype.unMap = function(key, epid, opts, cb) {
    this.features[epid].unMap(key, opts, cb);
};

UcpDevice.prototype.notify = function(epid, id, payload, opts, cb) {
    this.features[epid].notify(id, payload, opts, cb);
};

UcpDevice.prototype.read = function(id, opts, cb) {
    var endpoint = this.getFeature(id);
    if(!endpoint) {
        return cb(true, 'Not found: '+id);
    }
    if(typeof endpoint.read !== 'function') {
        return cb(true, 'Not readable: '+id);
    }
    
    endpoint.read(opts, cb);
};

UcpDevice.prototype.model = function(opts, cb) {
    var response = {
        device: this.name,
        model: this.getFeatureModel(),
        enum: this.enum };

    cb(null, response);
};

UcpDevice.prototype.list = function() {
    return this.features;
};

/**
 * Make a copy of the features object, and replace write function with true.
 */
UcpDevice.prototype.getFeatureModel = function() {
    var model = {};
    for (var i in this.features) {
        model[i] = {};
        for (var j in this.features[i]) {
            switch(j) {
                case 'data':
                    model[i][j] = this.features[i][j];
                    model[i]['read'] = true;
                    break;
                case 'write':
                    model[i][j] = true;
                    break;
                case 'invoke':
                    model[i][j] = true;
                    break;
                case 'read':
                    // all features inherit a read function, but skip it in the model (See. data)
                    break;
                case 'label':
                case 'type':
                case 'tag':
                case 'value':
                case 'unit':
                case 'scale':
                case 'ref':
                case 'hint':
                case 'features': // this one should be recursive, get subitems
                case 'mappings':
                    model[i][j] = this.features[i][j];
                    break;
                default:
                    break;
            }
        }
    }
    return model;
};

module.exports = {
    UcpDevice: UcpDevice };