/*

var WishCore = require('wish-core').WishCore;
var ucpService = require('../src/application.js');
var BSON = require('wish-bson').BSONPure.BSON;
var fs = require('fs');

var setup = {};

describe('ucp-core', function() {
    
    it('should start a basic wish network', function(done) {
        
        var configA = {
            id: 'a4810c0bef8b4ceca19104cde1a6528c60d6aa5576edd3b34f109536b860fe6b',
            port: 38000,
            rpcport: 39000,
            dhtport: 1249,
            //relay: "194.142.159.165:37008",
            identity: { noload:true },
            resources: { db: "a.db" },
            services: { noload:true }
        };
        var configB = {
            id: 'b4810c0bef8b4ceca19104cde1a6528c60d6aa5576edd3b34f109536b860fe6b',
            port: 38001,
            rpcport: 39001,
            dhtport: 1248,
            //relay: "194.142.159.165:37008",
            identity: { noload:true },
            resources: { db: "b.db" },
            services: { noload:true }
        };
        var ucpServiceConfigA = {
            service: {
                meta: {
                    name: "UCP Service A",
                    desc: "Universal Control Protocol service (A)",
                    type: "application",
                    protocols: [{name: "ucp"}],
                    version: "0.1.0"},
                instance: "ucp-ui"},
            core: {
                ws: "ws://localhost:39000"}};
        
        var ucpServiceConfigB = {
            service: {
                meta: {
                    name: "UCP Service B",
                    desc: "Universal Control Protocol service (B)",
                    type: "application",
                    protocols: [{name: "ucp"}],
                    version: "0.1.0"},
                instance: "ucp-dev-1"},
            core: {
                ws: "ws://localhost:39001"}};

        var ucpServiceConfigC = {
            service: {
                meta: {
                    name: "UCP Service C",
                    desc: "Universal Control Protocol service (C)",
                    type: "application",
                    protocols: [{name: "ucp"}],
                    version: "0.1.0"},
                instance: "ucp-dev-2"},
            core: {
                ws: "ws://localhost:39001"}};


        // starting up scenario

        var coreB;
        var coreA = new WishCore(configA, function(core) {
            //console.log("Core A ready!");
            
            core.rpc.invoke('identity.create', ['Control Identity'], function(d) {
                var msg = BSON.deserialize(d);
                var identity = msg.data.id;
                var userA = { wuid: identity.id };
                //console.log("User A created: ",msg);
                
                coreB = new WishCore(configB, function(core) {
                    //console.log("Core B ready!");


                    core.rpc.invoke('identity.create', ['Device Identity'], function(d) {
                        var msg = BSON.deserialize(d);
                        var identity = msg.data.id;
                        var userB = { wuid: identity.id };
                        //console.log("User B created: ",msg);
                        
                        var ucpServiceA = ucpService.start(ucpServiceConfigA);
                        
                        
                        try {
                            var model = JSON.parse(fs.readFileSync(__dirname+'/model.json'));
                        } catch (e) {
                            console.log("Failed reading model.json");
                        }
                        var ucpServiceB = ucpService.start(ucpServiceConfigB, model);
                        var ucpServiceC;
                        
                        setup.ucpServiceA = ucpServiceA;
                        setup.ucpServiceB = ucpServiceB;
                        
                        
                        //console.log(ucpServiceA);
                        
                        ucpServiceA.on('quarantined', function() {
                            //console.log("Connected B to core.");
                            coreA.rpc.invoke('services.listQuarantine', [], function(d) {
                                var msg = BSON.deserialize(d);
                                //console.log("msg:",msg);

                                for (var i in msg.data) {
                                    //console.log("index:",i);
                                    coreA.rpc.invoke('services.acceptQuarantinedService', [i], function(d) {
                                        var msg = BSON.deserialize(d);
                                        
                                        if ( msg.data === true ) {
                                            
                                            ucpServiceB.on('quarantined', function() {
                                                coreB.rpc.invoke('services.acceptQuarantinedService', [ucpServiceConfigB.service.instance], function(d) {
                                                    var msg = BSON.deserialize(d);

                                                    if ( msg.data === true ) {

                                                        setup.ucpServiceC = ucpService.start(ucpServiceConfigC, model)
                                                        setup.ucpServiceC.on('quarantined', function() {
                                                            coreB.rpc.invoke('services.acceptQuarantinedService', [ucpServiceConfigC.service.instance], function(d) {
                                                                var msg = BSON.deserialize(d);
                                                                if (msg.data === true) {
                                                                    setup.coreA = coreA;
                                                                    setup.coreB = coreB;
                                                                    setup.userA = userA;
                                                                    setup.userB = userB;
                                                                    done();
                                                                }
                                                            });
                                                        });


                                                    }
                                                });
                                            });
                                        }
                                    });
                                }
                            });
                        });
                        
                    });
                });
            });
        });
        
        process.on('SIGINT', function() {
            process.exit();
        });

        process.on('SIGTERM', function() {
            process.exit();
        });

        process.on('exit', function() {
            try {
                coreA.shutdown();
            } catch(e) {
                console.log("Fail A", e);
            }
            try {
                coreB.shutdown();
            } catch(e) {
                console.log("Fail B", e);
            }
        });


        
    });
    
    it('should perform step 1 of usb authentication process', function(done) {
        
        setup.coreA.rpc.invoke('identity.exportPublic', [setup.userA.wuid], function(d) {
            var msg = BSON.deserialize(d);
            //var identity = msg.data.id;
            //console.log("User export data", msg);
            var id = msg.data;
            
            setup.coreB.rpc.invoke('identity.import', [id.alias, id.pubkey, id.curve, id.transports, setup.userB.wuid], function(d) {
                var msg = BSON.deserialize(d);
                //var identity = msg.data.id;
                //console.log("User import data", msg);
                setup.userB.userA = { 
                    transports: id.transports,
                    wuid: msg.data.id
                };
                done();
            });
            
        });
    });
    
    it('should perform step 2 of usb authentication process', function(done) {
        
        setup.coreB.rpc.invoke('identity.exportPublic', [setup.userB.wuid], function(d) {
            var msg = BSON.deserialize(d);
            //var identity = msg.data.id;
            //console.log("User export data", msg);
            var id = msg.data;
            
            setup.coreA.rpc.invoke('identity.import', [id.alias, id.pubkey, id.curve, id.transports, setup.userA.wuid], function(d) {
                var msg = BSON.deserialize(d);
                //var identity = msg.data.id;
                //console.log("User import data", msg);
                setup.userA.userB = { 
                    transports: id.transports,
                    wuid: msg.data.id
                };
                done();
            });
            
        });
    });
    
    it('should make Wish connection between A and B', function(done) {
        
        if ( setup.userA.userB.transports.length !== 1 ) {
            throw new Error('Expects only one transport to be available, must be fixed!');
        }
        
        setup.ucpServiceA.on('ucpNode', function(wishService, alias) {
            console.log("New UCP node found ", wishService.substr(0, 12), "provided by", alias);
        });
        
        setup.coreA.rpc.invoke('connections.connect', [setup.userA.wuid, setup.userA.userB.wuid, setup.userA.userB.transports[0]], function(d){
            var msg = BSON.deserialize(d);
            //console.log("connect response", d);
            
            setTimeout(function(){
                
                setup.coreA.rpc.invoke('connections.list', [setup.userA.wuid, setup.userA.userB.wuid], function(d){
                    var msg = BSON.deserialize(d);
                    //console.log("connection.list response", msg);
                    // TODO test connection actually opened
                    done();
                });
                
            },400);
            
        });
    });    

    
    it('should send message from A to B', function(done) {
        setup.ucpServiceA.test(function(){
            console.log("test emit", arguments);
            done();
        });
    });    
    

//    it('should return model from B to A', function(done) {
//        setup.ucpServiceA.getModel(function(){
//            //console.log("This is done...", arguments[0].data.items, arguments[0].data.enumerations);
//            done();
//        });
//    });
    
    
    it('should catch new devices being paired', function(done) {
        this.timeout(4000);
        setTimeout(function(){
            done();
        }, 300);
    });
        
    
});

*/