var EventEmitter = require('events').EventEmitter;
var BSON = require('wish-bson').BSONPure.BSON;
var Peer = require('./dep/peer.js').Peer;
var Server = require('wish-rpc').Server;
var Client = require('wish-rpc').Client;
var debug = require('debug')('wish-app/protocol.js');
var util = require('util');

function Protocol(name, rpc) {
    this.name = name;
    this.peerCache = {};
    if(rpc) {
        this.registerRpc(rpc);
    }
}

util.inherits(Protocol, EventEmitter);

Protocol.prototype.peer = function(peer) {
    var self = this;
    var url = peer.luid +'>'+ peer.ruid +'@'+ peer.rhid +'/'+ peer.rsid;
    //console.log("got peer in app.");
    if(peer.type === 'D') {
        this.emit('offline', this.peerCache[url]);
        this.emit('removed', this.peerCache[url]);
        delete this.peerCache[url];
        return;
    }
    
    if(!this.app.identities[peer.luid] || !this.app.identities[peer.ruid]) {
        if(!this.app.identities[peer.luid]) {
            console.log("cache miss.. looking for", peer.luid, 'in:', this.app.identities);
            this.app.coreClient.rpc('identity.get', [peer.luid], function(err, response) {
                if(err) { return; }

                self.app.identities[response.uid.toString('hex')] = response;
                self.updatePeerCache(peer, url);
            });
        }
        if(!this.app.identities[peer.ruid]) {
            console.log("cache miss.. looking for", peer.ruid, 'in:', this.app.identities);
            this.app.coreClient.rpc('identity.get', [peer.ruid], function(err, response) {
                if(err) { return; }

                self.app.identities[response.uid.toString('hex')] = response;
                self.updatePeerCache(peer, url);
            });
        }
    } else {
        self.updatePeerCache(peer, url);
    }
};

Protocol.prototype.updatePeerCache = function(peer, url) {
    var self = this;
    var p = Peer.copy(peer);

    p.l = self.app.alias(peer.luid);
    p.r = self.app.alias(peer.ruid);
    p.send = function(frame) {
        if(!Buffer.isBuffer(frame)) {
            return console.log("Trying to send something that is not a Buffer, that is deprecated.", frame);
        }
        self.app.send(p, frame);
    };

    // Check this: does updating the cache introduce other problems? Fixes offline then online: p.call staying Dummy peer.call
    //if( !self.peerCache[url] ) {
        self.peerCache[url] = p;
    //}

    //self.peerCache[url].online = p.online;
    if(!p.rpc && p.online) {
        // create rpc client for this peer
        p.rpc = new Client(function(data) {
            if(!p.online) { return; }
            if(process.env.MSG) { console.log("AppToApp(ClientReq OUT):", self.app.peerAlias(p), '\n'+util.inspect(data, null, 10, true)); }
            var frame = BSON.serialize(data);
            self.app.send(p, frame);
        });
        p.call = p.rpc.request.bind(p.rpc);
    }
    if(!p.call) {
        if(p.online) { console.log("setting dummy call function...", !!p.rpc, !!p.online); }
        p.call = function(op, args, cb) {
            if(!p.online) { 
                return cb(true, { code: 504, str: 'Peer offline.'}); 
            } 
            console.log("Dummy peer.call function. Arguments:", arguments, new Error().stack); 
        }; 
    }
    self.emit(p.online ? 'online' : 'offline', p);
};

Protocol.prototype.offline = function() {
    // mark everything as offline
    for(var i in this.peerCache) {
        if (this.peerCache[i].online) {
            this.peerCache[i].online = false;
            this.emit('offline', this.peerCache[i]);
        }
    }
};

// incoming frame from core
Protocol.prototype.frame = function(frame, peer) {
    this.emit('frame', frame, peer);
};

Protocol.prototype.send = function(peer, payload, cb) {
    this.app.send(peer, payload, cb);
};

Protocol.prototype.request = function(peer, op, args, cb) {
    var url = peer.luid +'>'+ peer.ruid +'@'+ peer.rhid +'/'+ peer.rsid;
    if(this.peerCache[url]) {
        this.peerCache[url].call(op, args, cb);
    } else {
        if(typeof cb === 'function') { 
            cb(true, { str: 'Peer not found in peerCache, not online?', code: 903 });
        }
    }
};

Protocol.prototype.broadcast = function(payload, luid) {
    //console.log("sending a message...");
    for(var i in this.peerCache) {
        var peer = this.peerCache[i];
        if(peer.online) {
            if(luid && peer.luid !== luid) { continue; }
            this.app.send(peer, payload, function(err, data) {
                if (err) { console.log("services.send returned:", err, data); }
            });
        }
    }
};

Protocol.prototype.registerApp = function(app) {
    var self = this;
    this.app = app;
    if(this.rpc) {
        // connect incoming frames to rpc and attach send handler
        this.on('frame', function(frame, peer) {
            var handler = function(data) {
                if(process.env.MSG) { console.log("AppToApp(ServerRes OUT):", self.app.peerAlias(peer), '\n'+util.inspect(data, null, 10, true)); }
                self.send(peer, BSON.serialize(data));
            };
            
            try {
                var msg = BSON.deserialize(frame);
            } catch(e) {
                return console.log("Got message that is not BSON.", frame);
            }

            var url = peer.luid +'>'+ peer.ruid +'@'+ peer.rhid +'/'+ peer.rsid;

            if (msg.op || msg.end) {
                if(process.env.MSG) { console.log("AppToApp(ClientReq IN):", self.app.peerAlias(peer), '\n'+util.inspect(msg, null, 10, true)); }
                self.rpc.parse(msg, handler, { peer: peer }, url);
            } else {
                if(process.env.MSG) { console.log("AppToApp(ClientRes IN):", self.app.peerAlias(peer), '\n'+util.inspect(msg, null, 10, true)); }
                if(!self.peerCache[url]) { return console.log("Frame from unknown peer.", self.app.peerAlias(peer)); }
                self.peerCache[url].rpc.messageReceived(msg);
            }
            
        });
        this.on('offline', function(peer) {
            //console.log("wish.app/protocol: offline:", peer);
            var url = peer.luid +'>'+ peer.ruid +'@'+ peer.rhid +'/'+ peer.rsid;
            self.rpc.clientOffline(url);
        });
    }
};

Protocol.prototype.registerRpc = function(rpc) {
    var self = this;
    this.rpc = new Server(rpc);
    this.rpc.accessControl(function(resource, permissions, context, cb) {
        resource = self.name +'#'+ resource;

        if(!Array.isArray(permissions)) {
            console.log('Permissions not array:', permissions, new Error().stack);
            return cb(new Error('Permissions not array:'+JSON.stringify(permissions, null, 2)));
        }

        if(permissions.length > 1) {
            // several permissions to check, find all allowed permissions
            //debug("Checking for allowed permissions:", permissions, ' to resource:', resource);
            self.app.core('services.acl.allowedPermissions', [resource, context.peer], function(err, data) {
                if(err) { return cb(true, false); }
                cb(null, data[resource].length>0, data[resource]);
            });
        } else if (permissions.length === 1) {
            // only one permission to check, ask for specific permission
            //debug("Checking for allowed permission:", permissions[0], ' to resource:', resource);
            self.app.core('services.acl.check', [resource, permissions[0], context.peer], function(err, allowed) {
                if(err) { return cb(true, false); }
                try {
                    if(!allowed) {
                        var user = context.peer.ruid +'@'+ context.peer.rhid +'/'+context.peer.rsid;
                        //debug('Permission denied: ('+context.peer.luid+' '+user +' '+ resource, permissions[0], ')');
                    }
                    cb(null, allowed, allowed ? permissions : []);
                } catch(e) {
                    console.log("Fail fail fail...", e, e.stack);
                    cb(null, false, []);
                }
            });
        } else {
            console.log("Something unexpected came up...", permissions);
        }
    });    
};

module.exports = {
    Protocol: Protocol
};
