var CoreClient = require('./dep/core-client.js').CoreClient;
var Peer = require('./dep/peer.js').Peer;
var EventEmitter = require('events').EventEmitter;
var ed25519 = require('ed25519');
var crypto = require('crypto');
var debug = require('debug')('wish-app');
var util = require('util');

"use strict";

function App(name, protocols, url, permissions, wsid) {
    if(typeof name === 'object') {
        protocols = name.protocols;
        url = name.url;
        permissions = name.permissions;
        wsid = name.wsid;
        name = name.name;
    }
    this.name = name;
    this.permissions = permissions;
    this.coreClient = null;
    this.state = 'disconnected'; // quarantined, ready
    
    if( typeof this.name !== 'string' ) {
        throw new Error('App human readable name must be string, got:', typeof this.name);
    }

    var seed;
    
    if(process.env.WSID) {
        seed = crypto.createHash('sha256').update(process.env.WSID).digest();
    } else {
        seed = crypto.randomBytes(32);
    }
    
    this.keyPair = ed25519.MakeKeypair(seed);
    this.wsid = crypto.createHash('sha256').update(this.keyPair.publicKey).digest('hex');
    
    debug('wsid: '+ this.wsid);
    
    this.identities = {};
    this.protocols = {};
    for(var i in protocols) {
        this.protocols[protocols[i].name] = protocols[i];
        protocols[i].registerApp(this);
    }
    this.url = url;
    if(process.env.CORE) {
        this.url = process.env.CORE;
    }

    this.connect();
}

util.inherits(App, EventEmitter);

App.prototype.alias = function(wuid) {
    return (this.identities[wuid]?this.identities[wuid].alias:wuid.substr(0,6));
};

App.prototype.peerAlias = function(peer) {
    return this.alias(peer.luid) +'>'+ this.alias(peer.ruid) +'@'+ peer.rhid +'/'+ peer.rsid;
};

App.prototype.connect = function() {
    var self = this;
    this.coreClient = new CoreClient(this.keyPair, this.url?this.url:'localhost:9090');

    function readyHandler(whid) {
        self.whid = whid;
        var protocols = [];
        for(var i in self.protocols) {
            protocols.push(self.protocols[i].name);
        }

        self.coreClient.on('frame', function(frame) {
            frame.peer.l = self.alias(frame.peer.luid);
            frame.peer.r = self.alias(frame.peer.ruid);

            self.protocols[frame.peer.protocol].frame(frame.data, frame.peer);
        });

        self.coreClient.on('peer', function(peer) {
            if( self.protocols[peer.protocol] ) {
                self.protocols[peer.protocol].peer(peer);
            } else {
                console.log("Peer signal about protocol we don't want?:", peer.protocol);
            }
        });

        // wait for ready or quaratine signal form core
        self.coreClient.once('signal', function checkLogin(signal) {
            if(signal === 'ready') {
                debug("This WishApp's connection to core is ready.");
                // populate WishApp identity cache
                self.coreClient.rpc('identity.list', function(err, response) {
                    // convert uids to hex strings for internal use
                    for (var i in response) {
                        response[i].uid = response[i].uid.toString('hex');
                        self.identities[response[i].uid] = response[i];
                    }

                    function done() {
                        // send ready signal to core
                        self.coreClient.send({ ready: true });
                        
                        // mark self as ready
                        self.state = 'ready';

                        // now we are done
                        self.emit('ready');
                    }
                    
                    var ids = {};

                    var c = 0;
                    for (var i in response) {
                        c++;
                        ids[response[i].uid] = response[i];
                        (function(uid) {
                            self.coreClient.rpc('identity.get', [uid], function (err, data) {
                                ids[uid] = data;
                                c--;
                                if(c===0) {
                                    self.identities = ids;
                                    done();
                                }
                            });
                        })(response[i].uid);
                    }
                });
                return;
            } else if(signal === 'quarantine') {
                // we have been quarantined");
                debug('This WishApp is quarantined.');
                self.state = 'quarantined';
                self.emit('quarantine');
            } else {
                // something else happened, but keep waiting for ready signal
            }

            // keep waiting for ready signal
            self.coreClient.once('signal', checkLogin);
        });
        
        // login message
        self.coreClient.send({ wsid: self.wsid, name: self.name, protocols: protocols, permissions: self.permissions });
    }

    this.coreClient.once('ready', readyHandler);
    
    this.coreClient.on('close', function() {
        for(var i in self.protocols) {
            self.protocols[i].offline();
        }        
        self.state = 'disconnected';
        self.emit('close');
        self.coreClient.once('ready', readyHandler);
    });
};

App.prototype.send = function(peer, payload, cb) {
    peer = Peer.copyClean(peer);
    
    // temporary fix
    if(payload.length > 65535) {
        console.log("Too big payload:", payload.length, ' (limit: '+ 65535+')', new Error().stack);
        if(typeof cb === 'function') {
            cb(true, new Error('Too big payload:'+ payload.length));
        }
        return;
    }
    
    this.coreClient.rpc('services.send', [peer, payload], cb);
};

App.prototype.core = function(op, args, cb) {
    this.coreClient.rpc(op, args, cb);
};

App.prototype.disconnect = function() {
    this.state = 'disconnected';
    this.coreClient.close();
};

module.exports = {
    App: App
};
