var aesgcm = require('node-aes-gcm');
var BSON = require('wish-bson').BSONPure.BSON;
var inspect = require('util').inspect;

//   <Buffer ff ff ff ff ff ff ff fe>
// nonceInc(n)
//   <Buffer ff ff ff ff ff ff ff ff>
// nonceInc(n)
//   <Buffer 00 00 00 00 00 00 00 00>
function nonceInc(nonce) {
    var noncebin = nonce;
    var nonce1 = noncebin.readUInt32BE(4);
    var nonce2 = noncebin.readUInt32BE(0);
    nonce1+=1;
    if (nonce1 === 4294967296) {
        nonce1 = 0;
        nonce2+=1;
        if (nonce2 === 4294967296) {
            nonce2 = 0;
        }
        noncebin.writeUInt32BE(nonce2, 0);
    }
    noncebin.writeUInt32BE(nonce1, 4);
}
// AesGcm Socket Writer, actually
function AesGcm(key, iv, socket) {
    this.key = new Buffer(16);
    this.iv = new Buffer(12);
    this.socket = socket;
    
    key.copy(this.key);
    iv.copy(this.iv);
}

AesGcm.prototype.write = function(cleartext) {
    if (!this.socket.writable) {
        return false;
    }

    var auth = new Buffer([]);
    var e = aesgcm.encrypt(this.key, this.iv, cleartext, auth);
    nonceInc(this.iv.slice(4,12));

    var pklen = e.ciphertext.length + e.auth_tag.length;
    
    var pkl = new Buffer(2);
    pkl.writeUInt16BE(pklen, 0);

    if (process.env.NET) {
        try {
            var msg = BSON.deserialize(cleartext);
            var op = msg.op;
            var ack = msg.ack;

            console.log("OUT: Frame length with overhead:", (2+pklen), '|', op ? op+" (id: "+msg.id+")" : 'ack: '+ack);
            console.log(inspect(msg, null, 10, true));
        } catch(e) {
            console.log("f.", cleartext);
        }
    }

    this.socket.write(pkl);
    this.socket.write(e.ciphertext);
    return this.socket.write(e.auth_tag);
};

/**
 * Closes the underlying socket.
 */
AesGcm.prototype.end = function() {
    this.socket.end();
};


module.exports = {
    AesGcm: AesGcm };

