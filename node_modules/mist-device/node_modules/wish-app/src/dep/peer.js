
function Peer() {
    
}

Peer.equalPeer = function(a, b) {
    if( a.luid === b.luid && 
        a.ruid === b.ruid && 
        a.rsid === b.rsid &&
        a.protocol === b.protocol ) {
        return true;
    } else {
        return false;
    }
};

Peer.diffPeers = function(o, m) {
    var n = [];
    for(var l in m) {
        n.push(m[l]);
    }
    var l = [];
    for(var i in o) {
        var found = false;
        for(var j in n) {
            if( Peer.equalPeer(o[i], n[j]) ) {
                found = true;
                if( o[i].online !== n[j].online || o[i].services !== n[j].services ) {
                    // online status changed
                    l.push({ U: true, type: 'U', data: n[j] });
                }
                delete n[j];
            }
        }
        if (!found) {
            // this item is not present anymore
            l.push({ D: true, type: 'D', data: o[i] });
        }
    }

    // the rest is new
    for(var k in n) {
        l.push({ N: true, type: 'N', data: n[k] });
    }

    return l;
};

Peer.syncPeers = function(peers, data) {
    var type;
    var p = data.data;

    if (data.N) {
        type = 'N';
    } else if (data.D) {
        type = 'D';
    } else if (data.R) {
        type = 'R';
    } else if (data.U) {
        type = 'U';
    } else {
        console.log("None of the above (I,N,D,R,U):", data);
    }

    if(p) {
        var url = p.luid+'>'+p.ruid+'/'+p.rsid+'/'+p.protocol;
        if(type === 'D') {
            delete peers[url];
        } else if (type === 'R') {
            // initial list done
        } else {
            peers[url] = p;
        }
        //console.log("peer", type, p.l, '>', p.r, '/', p.s, '/', p.protocol, p.online);
    }
};

Peer.copy = function(peer) {
    return { 
        luid: peer.luid, 
        ruid: peer.ruid, 
        rhid: peer.rhid, 
        rsid: peer.rsid, 
        protocol: peer.protocol, 
        online: peer.online,
        s: peer.s
    };
};

Peer.copyClean = function(peer) {
    return { 
        luid: peer.luid, 
        ruid: peer.ruid, 
        rhid: peer.rhid, 
        rsid: peer.rsid, 
        protocol: peer.protocol
    };
};

Peer.copyCleanOnline = function(peer) {
    return { 
        luid: peer.luid, 
        ruid: peer.ruid, 
        rhid: peer.rhid, 
        rsid: peer.rsid, 
        protocol: peer.protocol,
        online: peer.online
    };
};

Peer.toString = function(peer) {
    return "peer "+ peer.l +'>'+ peer.r +'@ '+peer.rhid+' /'+ peer.rsid +'/'+ peer.protocol +', online: '+ peer.online;
};

Peer.printState = function(peers) {
    console.log("Peer state:");
    for(var i in peers) {
        var p = peers[i];
        console.log("  peer", p.l, '>', p.r, '@ '+p.rhid+' /', p.rsid, '/', p.protocol, p.online);
    }
};

// wish://luidhex>ruidhex@rhidhex/rsidhex
// luidhex>ruidhex@rhidhex/rsidhex
Peer.fromUrl = function urlToPeer(s) {
    var l = s.split('://');
    
    if(l.length !== 2) { l = s; }
    
    //var protocol = l[0];
    l = l[1].split('>');
    var luid = l[0];
    l = l[1].split('@');
    var ruid = l[0];
    l = l[1].split('/');
    var rhid = l[0];
    var rsid = l[1];
    
    return { luid: luid, ruid: ruid, rhid: rhid, rsid: rsid };
};

Peer.toUrl = function(peer) {
    return peer.luid +'>'+ peer.ruid +'@'+peer.rhid +'/'+ peer.rsid;
};

Peer.toRemoteUrl = function(peer) {
    return peer.ruid +'@'+peer.rhid +'/'+ peer.rsid;
};

module.exports = {
    Peer: Peer };
