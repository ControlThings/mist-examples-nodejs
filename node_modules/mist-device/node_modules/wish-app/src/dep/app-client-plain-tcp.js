var util = require('util');
var net = require('net');
var BSON = require('wish-bson').BSONPure.BSON;
var crypto = require('crypto');
var debug = require('debug')('TcpClient');
var EventEmitter = require('events').EventEmitter;
var SocketProtocol = require('./socket-protocol.js').SocketProtocol;

// emits new WishConnection on success
// emits error on Fail
// args {
//   address, (host)
//   port,
//   src: { id: wuid, alias: 'name' },
//   dst: { id: wuid, alias: 'name' },
// }

function writeFrame(socket, buffer) {
    var pkl = new Buffer(2);
    pkl.writeUInt16BE(buffer.length, 0);
    socket.write(pkl);
    socket.write(buffer);
}

//function TcpClient(core, args) {
function TcpClient(host, port, privBin, pubBin) {
    var self = this;
    
    // 
    this.establishTimeout = setTimeout(function establishTimeoutCb(){
        //console.log("establishTimeoutCb called");
        if ( self.socket && typeof self.socket.end === 'function') {
            self.socket.end();
        }
    }, 12400);
    
    var socket = net.createConnection({host: host, port: port});
    
    this.socket = socket;
    this.wishConnection = null;

    var protocol = new SocketProtocol(self.socket);
    
    self.socket.on('error', function(err) {
        //console.log("Socket client error:", err);
        if ( err.code === 'EHOSTUNREACH' ||Â err.code === 'ECONNREFUSED' ) {
            //debug('Emitting error on TcpClient', err);
            var error = {}; //new Error('TcpClient, EHOSTUNREACH');
            error.code = "EHOSTUNREACH";
            error.msg = "Host could not be reached.";
            self.emit('error', error);
        }
    });
    
    self.socket.on('close', function() {
        protocol.drop();
        protocol = null;
        self.emit('close');
    });
    
    protocol.on('connect', function() {
        
        var handshake = new Buffer(2+1);
        handshake.write("W.", 0, 2);
        handshake.write("19", 2, 1, 'hex');
        protocol.write(handshake);
        
        //writeFrame(protocol, pubBin);
        self.emit('ready', 'deadbeef'); //, whid);

        function frame(err,data) {
            if(err) return debug("Timeout C,A");
            var len = data.readUInt16BE(0);

            protocol.expect(len, function(err,payload) {
                if(err) { return debug("Timeout C,B"); }

                //console.log("AppClient: Wish message, emitting via connection object...!" , decryptedFrame);
                try {
                    self.emit('message', BSON.deserialize(payload));
                } catch(e) {
                    debug("BSON parse error B decrypted", payload);
                    debug("Stacktrace:", e.stack);
                }

                protocol.expect(2, frame);
            });
        }

        function firstFrame(err,data) {
            if(err) return debug("Timeout C,A");
            var len = data.readUInt16BE(0);

            protocol.expect(len, function(err,payload) {
                if(err) { return debug("Timeout C,B"); }

                // create a generic Wish Connection instance
                clearTimeout(self.establishTimeout);
                // connection established
                //var whid = crypto.createHash('sha256').update(corePubKey).digest('hex');
                self.emit('ready', 'deadbeef'); //, whid);

                console.log("First frame in app-client", BSON.deserialize(payload));

                try {
                    self.emit('message', BSON.deserialize(payload));
                } catch(e) {
                    debug("BSON parse error B decrypted", payload);
                    debug("Stacktrace:", e.stack);
                }
                    
                protocol.expect(2, frame);
            });
        }

        protocol.expect(2, firstFrame);
    });
}

util.inherits(TcpClient, EventEmitter);

TcpClient.prototype.close = function() {
    this.socket.end();
};

TcpClient.prototype.send = function(msg) {
    console.log("sending", msg);
    writeFrame(this.socket, BSON.serialize(msg));
};

module.exports = {
    TcpClient: TcpClient };
