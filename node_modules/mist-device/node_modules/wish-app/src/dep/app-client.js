var util = require('util');
var net = require('net');
var BSON = require('wish-bson').BSONPure.BSON;
var crypto = require('crypto');
var debug = require('debug')('TcpClient');
var ed25519 = require('ed25519');
var EventEmitter = require('events').EventEmitter;
var aesgcm = require('node-aes-gcm');
var SocketProtocol = require('./socket-protocol.js').SocketProtocol;
var AesGcm = require('./aes-gcm.js').AesGcm;

// emits new WishConnection on success
// emits error on Fail
// args {
//   address, (host)
//   port,
//   src: { id: wuid, alias: 'name' },
//   dst: { id: wuid, alias: 'name' },
// }

function writeFrame(socket, buffer) {
    var pkl = new Buffer(2);
    pkl.writeUInt16BE(buffer.length, 0);
    socket.write(pkl);
    socket.write(buffer);
}

//function TcpClient(core, args) {
function TcpClient(host, port, privBin, pubBin) {
    var self = this;
    
    // 
    this.establishTimeout = setTimeout(function establishTimeoutCb(){
        //console.log("establishTimeoutCb called");
        if ( self.socket && typeof self.socket.end === 'function') {
            self.socket.end();
        }
    }, 12400);
    
    var socket = net.createConnection({host: host, port: port});
    
    this.socket = socket;
    this.wishConnection = null;

    var protocol = new SocketProtocol(self.socket);
    
    self.socket.on('error', function(err) {
        //console.log("Socket client error:", err);
        if ( err.code === 'EHOSTUNREACH' ||Â err.code === 'ECONNREFUSED' ) {
            //debug('Emitting error on TcpClient', err);
            var error = {}; //new Error('TcpClient, EHOSTUNREACH');
            error.code = "EHOSTUNREACH";
            error.msg = "Host could not be reached.";
            self.emit('error', error);
        }
    });
    
    self.socket.on('close', function() {
        protocol.drop();
        protocol = null;
        self.emit('close');
    });
    
    protocol.on('connect', function() {
        
        var handshake = new Buffer(2+1);
        handshake.write("W.", 0, 2);
        handshake.write("18", 2, 1, 'hex');
        protocol.write(handshake);
        
        writeFrame(protocol, pubBin);

        var dhe = crypto.getDiffieHellman('modp15');
        dhe.generateKeys();

        var pubkey = dhe.getPublicKey();
        
        writeFrame(protocol, pubkey);
        
        protocol.expect(2, function(err,data) {
            if (err) return debug('caller.err', err);
            var len = data.readUInt16BE(0);

            protocol.expect(len, function(err, corePubKey) {
                if (err) return console.log("Timeout C,C", err);

                //console.log("client got pubkey", corePubKey);
                
                protocol.expect(2, function(err,data) {
                    if (err) return debug('caller.err', err);
                    var len = data.readUInt16BE(0);

                    protocol.expect(len, function(err,pubkey) {
                        if (err) return console.log("Timeout C,C", err);

                        //console.log("client got dhe pubkey", pubkey);

                        try {
                            var secret = dhe.computeSecret(pubkey);
                        } catch (e) {
                            console.log("dhe failed!", e, e.stack);
                            protocol.close();
                            return;
                        }

                        var key = secret.slice(0,16);
                        var iv = secret.slice(16,28);
                        var aesgcmOut = new AesGcm(key,iv,self.socket);

                        var clientHash = crypto.createHash('sha256').update('client').update(secret).digest();
                        var serverHash = crypto.createHash('sha256').update('server').update(secret).digest();
                        var signature = ed25519.Sign(clientHash, privBin);

                        // send signature
                        aesgcmOut.write(signature);

                        protocol.state = 1;

                        function frame(err,data) {
                            if(err) return debug("Timeout C,A");

                            var len = data.readUInt16BE(0);

                            protocol.expect(len, function(err,payload) {
                                if(err) return debug("Timeout C,B");

                                var auth_tag = payload.slice(len-16, len);
                                var ciphertext = payload.slice(0,len-16);
                                var decryptedFrame = aesgcm.decrypt(secret.slice(32+0,32+16), secret.slice(32+16,32+28), ciphertext, new Buffer([]), auth_tag);
                                nonceInc(secret.slice(32+20,32+28));

                                if ( !decryptedFrame.auth_ok ) {
                                    debug("Fatal error: Decrypted frame could not be authenticated.");
                                    return;
                                }

                                if ( protocol.state === 1 ) {
                                    var signature = decryptedFrame.plaintext;

                                    var verification = ed25519.Verify(serverHash, signature, corePubKey);

                                    if(verification !== true) {
                                        protocol.close();
                                        protocol.drop();
                                        return;
                                    }

                                    protocol.state = 2;

                                    // create a generic Wish Connection instance
                                    clearTimeout(self.establishTimeout);
                                    // connection established
                                    var whid = crypto.createHash('sha256').update(corePubKey).digest('hex');
                                    self.aes = aesgcmOut;
                                    self.emit('ready', whid);
                                } else {
                                    //console.log("AppClient: Wish message, emitting via connection object...!" , decryptedFrame);
                                    try {
                                        self.emit('message', BSON.deserialize(decryptedFrame.plaintext));
                                    } catch(e) {
                                        debug("BSON parse error B decrypted", decryptedFrame);
                                        debug("Stacktrace:", e.stack);
                                    }
                                }

                                protocol.expect(2, frame);
                            });
                        }

                        protocol.expect(2, frame);
                    });
                });
            });
        });
    });
}

util.inherits(TcpClient, EventEmitter);

TcpClient.prototype.close = function() {
    this.socket.end();
};

TcpClient.prototype.send = function(msg) {
    this.aes.write(BSON.serialize(msg));
};


//   <Buffer ff ff ff ff ff ff ff fe>
// nonceInc(n)
//   <Buffer ff ff ff ff ff ff ff ff>
// nonceInc(n)
//   <Buffer 00 00 00 00 00 00 00 00>
function nonceInc(nonce) {
    var noncebin = nonce;
    var nonce1 = noncebin.readUInt32BE(4);
    var nonce2 = noncebin.readUInt32BE(0);
    nonce1+=1;
    if (nonce1 === 4294967296) {
        nonce1 = 0;
        nonce2+=1;
        if (nonce2 === 4294967296) {
            nonce2 = 0;
        }
        noncebin.writeUInt32BE(nonce2, 0);
    }
    noncebin.writeUInt32BE(nonce1, 4);
}

module.exports = {
    TcpClient: TcpClient };
