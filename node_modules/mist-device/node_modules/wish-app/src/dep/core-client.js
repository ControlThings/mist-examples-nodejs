var EventEmitter = require('events').EventEmitter;
var debug = require('debug')('core-client');
if(process.env.TCP) {
    var TcpClient = require('./app-client-plain-tcp.js').TcpClient;
} else {
    var TcpClient = require('./app-client.js').TcpClient;
}
var RpcClient = require('wish-rpc').Client;
var crypto = require('crypto');
var util = require('util');
var inspect = util.inspect;

"use strict";

function CoreClient(keyPair, url) {
    if(keyPair) {
        this.id = crypto.createHash('sha256').update(keyPair.publicKey).digest('hex');
        this.privkey = keyPair.privateKey;
        this.pubkey = keyPair.publicKey;
    } else {
        this.id = new Buffer('2afc61417d6760d4a93ce2e6ee5765639269798ccfd3d77427b16d5d5315d6e1', 'hex');
        this.privkey = new Buffer('fb2aa58782e4e1a91669f127109f34c0177ce09e3e8f68b5d6c6c33fcc01fac1a30cafc0f41975838af19daeca34e07104e986569697d352d6ce7f68d29972c7', 'hex');
        this.pubkey = new Buffer('a30cafc0f41975838af19daeca34e07104e986569697d352d6ce7f68d29972c7', 'hex');
    }
    
    this.autoConnect = true;
    this.connectToCore(url);
}

util.inherits(CoreClient, EventEmitter);

CoreClient.prototype.connectToCore = function(url) {
    var self = this;
    var host;
    var port = 9090;
    
    if(url) {
        host = url.split(':')[0];
        port = url.split(':')[1] || 9090;
    } else {
        host = 'localhost';
    }
    
    // override if env PORT is set
    port = process.env.PORT ? parseInt(process.env.PORT) : port;
    debug('Connecting to core on port', port);
    
    this.client = new TcpClient(host, port, this.privkey, this.pubkey);
    
    function readyHandler(whid) {
        debug("Got core host id:", whid);
        self.rpcClient = new RpcClient(function(msg) { self.send(msg); });

        var messageHandler = function(data) {
            if(process.env.FRAME) { console.log("CoreToApp:", inspect(data, null, 10, true)); }
            if(data.type === 'peer') {
                if( Buffer.isBuffer(data.peer.luid) ) { data.peer.luid = data.peer.luid.toString('hex'); }
                if( Buffer.isBuffer(data.peer.ruid) ) { data.peer.ruid = data.peer.ruid.toString('hex'); }
                if( Buffer.isBuffer(data.peer.rhid) ) { data.peer.rhid = data.peer.rhid.toString('hex'); }
                if( Buffer.isBuffer(data.peer.rsid) ) { data.peer.rsid = data.peer.rsid.toString('hex'); }
                self.emit('peer', data.peer);
            } else if(data.type === 'frame') {
                if( Buffer.isBuffer(data.peer.luid) ) { data.peer.luid = data.peer.luid.toString('hex'); }
                if( Buffer.isBuffer(data.peer.ruid) ) { data.peer.ruid = data.peer.ruid.toString('hex'); }
                if( Buffer.isBuffer(data.peer.rhid) ) { data.peer.rhid = data.peer.rhid.toString('hex'); }
                if( Buffer.isBuffer(data.peer.rsid) ) { data.peer.rsid = data.peer.rsid.toString('hex'); }
                self.emit('frame', data);
            } else if(data.type === 'signal') {
                self.emit('signal', data.signal);
            } else {
                self.rpcClient.messageReceived(data); //.bind(self.rpcClient);
            }
        };
        
        self.client.on('message', messageHandler);
        self.client.once('close', function() {
            // closing client connection to core, and cleaning up
            self.client.removeListener('message', messageHandler);
            self.removeAllListeners('peer');
            self.removeAllListeners('frame');
            self.removeAllListeners('signal');
            self.client = null;
            self.rpcClient.destroy();
            self.rpcClient = null;
            self.emit('close');

            debug('Core connection closed.');
            setTimeout(function() {
                if(self.autoConnect) {
                    self.connectToCore(url);
                }
            }, 1000);
        });
        
        self.emit('ready', whid);
    }
    
    this.client.once('ready', readyHandler);
    
    self.client.once('error', function(err) {
        //console.log("error, reconnecting...");
        setTimeout(function() {
            if(self.autoConnect) {
                self.connectToCore(url);
            }
        }, 1000);
    });
    
};

CoreClient.prototype.send = function(msg) {
    if(process.env.FRAME) { console.log("AppToCore:", inspect(msg, null, 10, true)); }
    
    this.client.send(msg);
};

CoreClient.prototype.rpc = function(op, args, cb) {
    this.rpcClient.request(op, args, cb);
};

CoreClient.prototype.close = function() {
    this.autoConnect = false;
    if(this.client) {
        this.client.close();
    }
};

module.exports = {
    CoreClient: CoreClient };
