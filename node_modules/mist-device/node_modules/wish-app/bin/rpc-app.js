/**
 * Minimalistic Chat for Wish
 * 
 * Run two clients with different WSIDs.
 *   WSID=chat1 node chat.js
 */

var App = require('../src/app.js').App;
var Protocol = require('../src/protocol.js').Protocol;

var fs = require('fs');

var resources = {
    battery: {
        status: 'r',
        voltage: 'r'
    },
    gps: {
        enabled: 'rw',
        lon: 'r',
        lat: 'r'
    }
};

var pattern = /\x1B\[([ABCD])/gm; // dump control characters

var chat = new Protocol('chat', {
    _message: { acl: [] },
    message: function(req, res, context) {
        var peer = context.peer;
        var data = req.args[0];
        
        if(context.permissions.write) {
            console.log("There is write permission.");
        }
        
        console.log("\u001b[34m"+ peer.r +'\u001b[37m>\u001b[34m'+peer.l+"\u001b[39m "+(context.permissions.admin?'orders':'says')+":", "\u001b[32m"+data.toString().replace(pattern, "")+"\u001b[39m"); //, "("+peer.l+", "+peer.rhid+"/"+peer.rsid+")");
        //res.send();
    },
    _read: { acl: true },
    read: function(req, res, context) {
        var endpoint = req.args[0];
        
        this.acl('model.'+endpoint, 'read', function(err, allowed) {
            console.log("Got response to advanced ACL check:", endpoint, 'read', allowed);
            if(allowed) {
                res.send('status: good');
            } else {
                res.error({ str: 'denied', code: 105 });
            }
        });
    },
    _write: { acl: true },
    write: function(req, res, context) {
        var endpoint = req.args[0];
        
        this.acl('model.'+endpoint, 'write', function(err, allowed) {
            //console.log("Got response to advanced ACL check:", endpoint, 'write', allowed);
            if(allowed) {
                res.send('status: updated');
            } else {
                res.error({ str: 'denied', code: 105 });
            }
        });
    },
    _like: { public: true, acl: ['admin'] },
    like: function(req, res, context) {
        if(context.acl.admin) {
            console.log("You are an admin.");
        } else {
            console.log("You are NOT an admin.");
        }
        var peer = context.peer;
        console.log("like context:", context);
        console.log("\u001b[34m"+ peer.r +red+'\u2764\u001b[34m'+peer.l+"\u001b[39m");
        //res.send();
    },
    _stress: { acl: ['god', 'devil'] },
    stress: function(req, res, context) {
        console.log('Getting stressed out... by the right of', context.permissions)
        res.send('Getting stressed out... by the right of'+JSON.stringify(context.permissions, null, 2));
    },
    _get: {},
    get: function(req, res, context) {
        var peer = context.peer;
        res.send(fs.readFileSync('./testconf.conf'));
    }
});

var white = '\u001b[37m>';
var yellow = '\u001b[33m';
var red = '\u001b[31m';
var green = '\u001b[34m';
var blue = '\u001b[32m';
var reset = '\u001b[39m';

chat.on('discovered', function(peer) {
    console.log("("+ peer.r +"@"+ peer.rhid +"/"+ peer.rsid +" discovered)");
    chat.allow(peer); // allow messages from this peer, starts triggering online/offline messages
    chat.deny(peer); // deny messages from this peer
});

chat.on('online', function(peer) {
    console.log(green + peer.r + reset +" entered, peer of "+peer.l+")");
    //peer.call('message', ['Hi there '+peer.r]);
});

chat.on('offline', function(peer) {
    console.log("("+ yellow + peer.r + reset +" left, was peer of "+peer.l+")");
});

process.stdin.setEncoding('utf8');

process.stdin.on('data', function(data) {
    var cmd = data.trim();
    if(cmd === '/peers') {
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            console.log((peer.online?green:yellow)+ peer.l +white+(peer.online?green:yellow)+peer.r+reset, i);
        }
        return;
    } else if(cmd.substr(0,5) === '/like') {
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('like');
        }
        return;
    } else if(cmd.substr(0,6) === '/allow') {
        var args = cmd.substr(6).trim().split(' ');
        app.core('services.acl.allow', [args[0], args[1], args[2], args[3]], function(err, data) {
            console.log("ChatRpcApp: Core allow:", err, data);
        });
        return;
    } else if(cmd.substr(0,7) === '/revoke') {
        var args = cmd.substr(7).trim().split(' ');
        app.core('services.acl.revoke', [args[0], args[1], args[2], args[3]], function(err, data) {
            console.log("ChatRpcApp: Core revoke:", err, data);
        });
        return;
    } else if(cmd.substr(0,6) === '/order') {
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('message', [cmd.substr(6).trim(), 'order.tough'], function(err, response) {
                if(err) { return console.log("Error delivering message:", data, err, response); }
                console.log("This messages was delivered.", data, err, response);
            });
        }
        return;
    } else if(cmd.substr(0,7) === '/stress') {
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('stress', [], function(err, response) {
                if(err) { return console.log("Error delivering message:", data, err, response); }
                console.log("This messages was delivered.", data, err, response);
            });
        }
        return;
    } else if(cmd.substr(0,6) === '/model') {
        //console.log("reading");
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('control.model', [], function(err, data) {
                if(err) { return console.log("Could not read, error:", data); }
                console.log("This is good, got:", data);
            });
        }
        return;
    } else if(cmd.substr(0,5) === '/read') {
        //console.log("reading");
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('control.read', [cmd.substr(5).trim()], function(err, data) {
                if(err) { return console.log("Could not read, error:", data); }
                console.log("This is good, got:", data);
            });
        }
        return;
    } else if(cmd.substr(0,6) === '/write') {
        //console.log("reading");
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('write', [cmd.substr(6).trim()], function(err, data) {
                if(err) { return console.log("Could not write, error:", data); }
                console.log("This is good, got:", data);
            });
        }
        return;
    } else if(cmd === '/get') {
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            peer.call('get', [], function(err, data) {
                if(err) { return console.log("Could not get, error:", data); }
                fs.writeFileSync('./tempout.dat', data);
            });
        }
        return;
    }
    
    var msg = data.trim().replace(pattern, "");
    if(msg !== '') {
        for(var i in chat.peerCache) {
            var peer = chat.peerCache[i];
            if(!peer.online) { continue; }
            peer.call('message', [msg], function(err, response) {
                if(err) { return console.log("Error delivering message:", data, err, response); }
                console.log("This messages was delivered.", data, err, response);
            });
        }
    }
});

//chat.publish(Alice, Bob); // triggers discovered in Bob's chat services with Bob>Alice@alice/chat1
//chat.publishAll(); // calls publish for all identities and all their contacts

var app = new App('Advanced Messaging App', [chat], null, ['identity.list', 'services.listPeers']);

app.on('ready', function() {
    console.log("Chat is connected to core. WSID:", app.wsid);
});

